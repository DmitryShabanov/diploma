{
  "header": {
    "about": "About",
    "binary": "Binary tree",
    "avl": "AVL tree"
  },
  "about": {
    "title": "About us",
    "p1": "Welcome! You are on the training portal, which will help you understand the trees, their standing and methods. It is written this whole thing within the framework of the diploma project by two (one) adventurers (students).",
    "p2": "Trees that are represented here:",
    "p2l1": "A binary search tree – is a hierarchical data structure in which each node has no more than two children. As a rule, the first is called the parent node, and children are called the left and right heirs.",
    "p2l2": "AVL-tree – is a height-balanced binary search tree: for each of its vertices the height of its two subtrees differs by not more than one. AVL is an abbreviation formed by the first letters of the names of the creators (Soviet scientists) Georgy Maksimovich Adelson-Velsky and Yevgeny Mikhailovich Landis. It was invented in 1962.",
    "bt1": "A binary search tree – is a binary tree for which the following additional conditions are met:",
    "bt1l1": "Both subtrees, left and right, are binary search trees.",
    "bt1l2": "For all nodes of the left subtree of an arbitrary node X, the values of the data keys are less than the value of the data key of the node X.",
    "bt1l3": "For all nodes of the right subtree of an arbitrary node X, the values of the data keys are greater or equal than the value of the data key of the node X.",
    "bt2": "The main advantage of a binary search tree over other data structures is the possible high efficiency of implementing search and sort algorithms based on it.",
    "bt3": "Basic operations in the binary search tree:",
    "bt3l1": "FIND (K) - search for the node in which the key (value) is stored with key = K.",
    "bt3l2": "INSERT (K, V) - adding a couple to the tree (key, value) = (K, V).",
    "bt3l3": "REMOVE (K) - delete the node in which the key (value) is stored with key = K.",
    "avl1": "AVL-tree – is a self-balancing search binary tree. Saves all the basic properties of the binary search tree, and adds one new property: for each of its vertices, the height of its two subtrees differs by no more than 1. The basic operations remain the same as in the binary search tree."
  },
  "binary": {
    "title": "Binary tree",
    "i1": "Inserting the new node",
    "i2": "New node",
    "i3": "< node",
    "i4": ", and left child is empty => node",
    "i5": "left child = node",
    "i6": "Node inserted!",
    "i7": ", and left child is not empty => go to the left subtree",
    "i8": "> node",
    "i9": "and right child is empty => node",
    "i10": "right child = node",
    "i11": "and right child is not empty => go to the right subtree",
    "r1": "Deleting the node",
    "r2": "Tree is empty!",
    "r3": "The node",
    "r4": " => go to the left subtree",
    "r5": " => go to the right subtree",
    "r6": "= node",
    "r7": "and node have not children => node",
    "r8": "= null. Node removed!",
    "r9": "and node have right children => node",
    "r10": "= right subtree. Node removed!",
    "r11": "and node have left children => node",
    "r12": "= left subtree. Node removed!",
    "r13": "and node have two children => node",
    "r14": "= min node from right subtree(node",
    "r15": "). Then delete node",
    "r16": "from right subtree",
    "o1": "Pre-order traversal",
    "o2": "Display node",
    "o3": "In-order traversal",
    "o4": "Post-order traversal",
    "s1": "Searching the node",
    "s2": "There is no node in the tree!",
    "s3": "Searched node",
    "s4": "=> continue search in the left subtree",
    "s5": "=> continue search in the right subtree",
    "s6": "=> node is found!",
    "s7": "Searching the min node",
    "s8": "The min node found!",
    "s9": "Left child of the node",
    "s10": "is empty => the min node is",
    "s11": "Node",
    "s12": "have a left child => continue search in the left subtree",
    "s13": "Searching the max node",
    "s14": "The max node found!",
    "s15": "Right child of the node",
    "s16": "is empty => the max node is",
    "s17": "Node",
    "s18": "have a right child => continue search in the right subtree"
  },
  "avl": {
    "title": "AVL tree"
  },
  "legend": {
    "title": "Legend",
    "initialized": "Tree is initialized."
  },
  "controls": {
    "node": "Node",
    "add": "Add",
    "addE": "Add node",
    "delete": "Delete",
    "deleteE": "Delete node",
    "searche": "Search",
    "searcheE": "Search node",
    "prev": "Prev",
    "prevE": "Prev step",
    "next": "Next",
    "nextE": "Next step",
    "preorder": "Preorder",
    "preorderE": "Preorder traversal",
    "inorder": "Inorder",
    "inorderE": "Inorder traversal",
    "postorder": "Postorder",
    "postorderE": "Postorder traversal",
    "min": "Min",
    "minE": "Find min node",
    "max": "Max",
    "maxE": "Find max node"
  }
}
